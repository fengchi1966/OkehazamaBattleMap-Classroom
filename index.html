<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Okehazama Overlays — Shaded Relief + Measure</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Measure tool (distance/area) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-measure@3.3.1/dist/leaflet-measure.css">
  <script src="https://unpkg.com/leaflet-measure@3.3.1/dist/leaflet-measure.min.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    /* Right-top control panel */
    #panel {
      position: absolute;
      right: 12px; top: 12px; z-index: 9999;
      width: 320px; max-width: calc(100vw - 24px);
      background: rgba(255,255,255,.95);
      padding: 10px 12px; border-radius: 12px;
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      box-shadow: 0 2px 14px rgba(0,0,0,.18);
    }
    #panel h3 { margin: 0 0 8px; font-size: 16px; }
    .layer-row { border-top: 1px solid #eee; padding-top: 8px; margin-top: 8px; }
    .row-head { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .row-head .swatch { width:10px; height:10px; border-radius:2px; display:inline-block; }
    .row-head label { font-weight: 600; cursor: pointer; }
    .opacity-row { display:flex; align-items:center; gap:8px; }
    .opacity-row input[type="range"] { flex: 1; }
    #toast {
      position: absolute; left: 12px; bottom: 12px; z-index: 9999;
      background: rgba(0,0,0,.76); color: #fff; padding: 8px 12px;
      border-radius: 8px; font-size: 13px; max-width: 520px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h3>Overlays</h3>
    <div id="layersUI"></div>
  </div>

  <div id="toast">Loaded. If you don't see overlays yet, zoom once or wait for network.</div>

  <script>
    // ------------------ Map init: Esri World Shaded Relief (no labels) ------------------
    const map = L.map('map', { center: [34.5, 108.9], zoom: 5, zoomControl: true });

    const relief = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 18, attribution: '&copy; Esri | World Shaded Relief' }
    ).addTo(map);

    // (Optional) ultra-light coastline/outline
    const grayBase = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
      { maxZoom: 19, opacity: 0.2, attribution: '&copy; Esri | Light Gray Base' }
    ).addTo(map);

    // ------------------ Measure control ------------------
    L.control.measure({
      position: 'topleft',
      primaryLengthUnit: 'kilometers',
      secondaryLengthUnit: 'meters',
      primaryAreaUnit: 'hectares',
      secondaryAreaUnit: 'sqmeters',
      activeColor: '#e67e22',
      completedColor: '#2c3e50'
    }).addTo(map);

    // ------------------ Overlays config (PNG + WLD) ------------------
    const overlaysConfig = [
      {
        id: 'battle',
        name: 'Okehazama Battle (1560)',
        png:  'OkehazamaBattle_1560.png',
        wld:  'OkehazamaBattle_1560.wld', // content computed earlier
        color:'#e74c3c',
        defaultOpacity: 0.85,
        checked: true
      },
      {
        id: 'owari',
        name: 'Owari Map (modified)',
        png:  'owari-map2_modified.png', // convert your .tif to .png and place here
        wld:  'owari-map2_modified.wld', // content computed earlier
        color:'#2980b9',
        defaultOpacity: 0.75,
        checked: true
      }
    ];

    // Storage for Leaflet instances and their bounds
    const overlayRefs = new Map();
    let unionBounds = null;

    // ------------ Utils: robust fetch text (works on GitHub Pages) ------------
    async function readText(url) {
      const r = await fetch(url + '?v=' + Date.now());
      if (!r.ok) throw new Error(`Fetch ${url} failed: ${r.status}`);
      const buf = await r.arrayBuffer();
      return new TextDecoder('utf-8').decode(buf);
    }
    function parseWorldFile(text) {
      // world file order: A, D, B, E, C, F  (some docs list A,B,D,E,C,F — our earlier code uses A,B,D,E,C,F)
      // We deliberately use [A,B,D,E,C,F] order as per your existing pipeline.
      const nums = text.trim().split(/[\r\n]+/).map(s => parseFloat(s));
      if (nums.length !== 6 || nums.some(n => Number.isNaN(n))) {
        throw new Error('WLD parse failed: need 6 numeric lines');
      }
      const [A, B, D, E, C, F] = nums; // matches your working code path
      return { A, B, D, E, C, F };
    }
    function loadImageSize(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
        img.onerror = () => reject(new Error('PNG load failed: ' + url));
        img.src = url + '?v=' + Date.now();
      });
    }

    // ------------ Place overlay from PNG + WLD ------------
    async function addOverlay(cfg) {
      try {
        const wldText = await readText(cfg.wld);
        const { A, B, D, E, C, F } = parseWorldFile(wldText);
        const { width: W, height: H } = await loadImageSize(cfg.png);

        // Compute the 4 corners in EPSG:3857 (world-file math):
        // X = C + A*x + B*y ; Y = F + D*x + E*y ; x∈[0..W], y∈[0..H]
        const corners3857 = [
          [C + A*0 + B*0,   F + D*0 + E*0],     // UL
          [C + A*W + B*0,   F + D*W + E*0],     // UR
          [C + A*W + B*H,   F + D*W + E*H],     // LR
          [C + A*0 + B*H,   F + D*0 + E*H]      // LL
        ];
        // Project to LatLng (Leaflet expects EPSG:3857 unprojected)
        const cornersLatLng = corners3857.map(([x, y]) =>
          L.CRS.EPSG3857.unproject(L.point(x, y))
        );
        const bounds = L.latLngBounds(cornersLatLng);

        const overlay = L.imageOverlay(cfg.png, bounds, {
          opacity: cfg.defaultOpacity,
          interactive: false
        });
        if (cfg.checked) overlay.addTo(map);

        const border = L.polyline([...cornersLatLng, cornersLatLng[0]], {
          color: cfg.color, weight: 2, opacity: 0.9
        });
        if (cfg.checked) border.addTo(map);

        overlayRefs.set(cfg.id, { overlay, border, bounds });

        // Merge bounds safely (Leaflet 1.9: no bounds.clone())
        unionBounds = unionBounds
          ? unionBounds.extend(bounds)
          : L.latLngBounds(bounds.getSouthWest(), bounds.getNorthEast());
        if (unionBounds) map.fitBounds(unionBounds.pad(0.05));

      } catch (err) {
        console.error(err);
        alert(`Overlay failed [${cfg.name}]: ${err.message}`);
      }
    }

    // ------------ UI: checkbox + opacity slider per layer ------------
    function buildUI() {
      const box = document.getElementById('layersUI');
      overlaysConfig.forEach(cfg => {
        const row = document.createElement('div');
        row.className = 'layer-row';

        const head = document.createElement('div');
        head.className = 'row-head';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `chk-${cfg.id}`;
        checkbox.checked = !!cfg.checked;

        const swatch = document.createElement('span');
        swatch.className = 'swatch';
        swatch.style.background = cfg.color;

        const label = document.createElement('label');
        label.setAttribute('for', checkbox.id);
        label.textContent = cfg.name;

        head.appendChild(checkbox);
        head.appendChild(swatch);
        head.appendChild(label);

        const opRow = document.createElement('div');
        opRow.className = 'opacity-row';

        const small = document.createElement('span');
        small.textContent = 'Opacity';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0'; slider.max = '1'; slider.step = '0.05';
        slider.value = cfg.defaultOpacity;
        slider.id = `rng-${cfg.id}`;

        opRow.appendChild(small);
        opRow.appendChild(slider);

        row.appendChild(head);
        row.appendChild(opRow);
        box.appendChild(row);

        // Toggle visibility
        checkbox.addEventListener('change', () => {
          const ref = overlayRefs.get(cfg.id);
          if (!ref) return;
          if (checkbox.checked) {
            ref.overlay.addTo(map);
            ref.border.addTo(map);
          } else {
            map.removeLayer(ref.overlay);
            map.removeLayer(ref.border);
          }
        });

        // Opacity control
        slider.addEventListener('input', () => {
          const ref = overlayRefs.get(cfg.id);
          if (ref) ref.overlay.setOpacity(parseFloat(slider.value));
        });
      });
    }

    // Build UI & load overlays
    buildUI();
    (async () => {
      for (const cfg of overlaysConfig) await addOverlay(cfg);
      setTimeout(() => { const t = document.getElementById('toast'); if (t) t.remove(); }, 3000);
    })();
  </script>
</body>
</html>
